<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Evaluation Viewer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .file-input {
            padding: 8px 15px;
            border: 2px solid #3498db;
            border-radius: 5px;
            background: white;
            cursor: pointer;
        }

        .task-selector {
            padding: 8px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            min-width: 200px;
        }

        .metrics {
            display: flex;
            gap: 20px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .metric {
            background: #ecf0f1;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 14px;
        }

        .file-type-badge {
            background: #3498db;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
        }

        .toggle-comments {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 14px;
        }

        .content {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .content.maximized {
            grid-template-columns: 1fr;
        }

        .code-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .code-header {
            padding: 15px;
            background: #34495e;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .maximize-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .maximize-btn:hover {
            background: #2980b9;
        }

        .code-panel.hidden {
            display: none;
        }

        .code-content {
            padding: 0;
            overflow: auto;
            max-height: 800px;
            background: #1e1e1e;
            position: relative;
        }

        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            border: 1px solid #404040;
            border-radius: 5px;
            padding: 20px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
            overflow-x: auto;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }



        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }



        .reasoning-panel {
            grid-column: 1 / -1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .reasoning-header {
            padding: 15px;
            background: #8e44ad;
            color: white;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reasoning-header div {
            display: flex;
            gap: 8px;
        }

        .reasoning-content {
            padding: 20px;
            max-height: 400px;
            overflow: auto;
            background: #1e1e1e;
        }

        .diff-view {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }

        .diff-header {
            padding: 15px;
            background: #2c3e50;
            color: white;
            font-weight: bold;
        }

        .diff-content {
            padding: 15px;
        }

        .diff-selector {
            margin-bottom: 15px;
        }

        .diff-selector select {
            padding: 8px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
            margin-left: 10px;
        }

        .diff-block {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 15px;
            line-height: 1.5;
            white-space: pre-wrap;
            border: 1px solid #404040;
            border-radius: 5px;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
            overflow: auto;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
        }

        .metrics-view {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-top: 20px;
        }

        .metrics-header {
            padding: 15px;
            background: #8e44ad;
            color: white;
            font-weight: bold;
        }

        .metrics-content {
            padding: 20px;
        }

        .metrics-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 15px;
            font-size: 12px;
        }

        .metrics-table th {
            background: #f8f9fa;
            padding: 8px;
            text-align: left;
            border: 1px solid #ddd;
            font-weight: 600;
            color: #2c3e50;
        }

        .metrics-table td {
            padding: 6px 8px;
            border: 1px solid #ddd;
            text-align: center;
        }

        .metrics-table .metric-name {
            text-align: left;
            font-weight: 500;
        }

        .comparison-title {
            font-weight: bold;
            color: #2c3e50;
            margin: 15px 0 10px 0;
            font-size: 14px;
        }

        .line {
            display: block;
            padding: 2px 5px;
            margin: 1px 0;
        }

        .line-added {
            background-color: #1b4332;
            border-left: 3px solid #40916c;
            color: #a7f3d0;
        }

        .line-removed {
            background-color: #4a1e1e;
            border-left: 3px solid #dc2626;
            color: #fca5a5;
        }

        .line-context {
            background-color: transparent;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
        }

        .status-pass {
            background: #d4edda;
            color: #155724;
        }

        .status-fail {
            background: #f8d7da;
            color: #721c24;
        }

        .status-timeout {
            background: #fff3cd;
            color: #856404;
        }

        .status-not-evaluated {
            background: #6b7280;
            color: #f3f4f6;
        }

        .filter-controls {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-section {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .filter-section label {
            font-size: 12px;
            font-weight: bold;
            color: #2c3e50;
        }

        .filter-section select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
            font-size: 14px;
        }

        .apply-filters-btn {
            padding: 8px 16px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            height: fit-content;
        }

        .apply-filters-btn:hover {
            background: #2980b9;
        }

        .task-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .task-status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            display: inline-block;
        }

        .task-status-pass {
            background: #27ae60;
        }

        .task-status-fail {
            background: #e74c3c;
        }

        .task-status-timeout {
            background: #f39c12;
        }

        .task-status-not-evaluated {
            background: #95a5a6;
        }

        .insights-panel {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            padding: 20px;
        }

        .insights-header {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }

        .insights-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .insight-item {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            border-left: 4px solid #3498db;
        }

        .insight-item.fail {
            border-left-color: #e74c3c;
        }

        .insight-item.high-diff {
            border-left-color: #f39c12;
        }

        .insight-item.pass {
            border-left-color: #27ae60;
        }

        .insight-item.timeout {
            border-left-color: #f39c12;
        }

        .insight-item.metric {
            border-left-color: #9b59b6;
        }

        .insight-item.not-evaluated {
            border-left-color: #95a5a6;
        }

        .insight-item.not-evaluated .insight-value {
            color: #95a5a6;
        }

        .insight-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #2c3e50;
        }

        .insight-value {
            font-size: 24px;
            font-weight: bold;
            color: #3498db;
            margin-bottom: 5px;
        }

        .insight-item.fail .insight-value {
            color: #e74c3c;
        }

        .insight-item.pass .insight-value {
            color: #27ae60;
        }

        .insight-item.timeout .insight-value {
            color: #f39c12;
        }

        .insight-item.high-diff .insight-value {
            color: #f39c12;
        }

        .insight-item.metric .insight-value {
            color: #9b59b6;
        }

        .insight-item.not-evaluated {
            border-left-color: #95a5a6;
        }

        .insight-item.not-evaluated .insight-value {
            color: #95a5a6;
        }

        .insight-description {
            font-size: 12px;
            color: #666;
        }

        @media (max-width: 1200px) {
            .content {
                grid-template-columns: 1fr 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr 1fr;
            }
            
            .controls {
                flex-direction: column;
                align-items: stretch;
            }

            .filter-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .insights-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .content {
                grid-template-columns: 1fr;
            }

            .metrics-table {
                font-size: 10px;
            }

            .metrics-table th,
            .metrics-table td {
                padding: 4px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Code Evaluation Viewer</h1>
            <div class="controls">
                <input type="file" id="fileInput" class="file-input" accept=".json,.jsonl" />
                <select id="taskSelector" class="task-selector" disabled>
                    <option value="">Select a task...</option>
                </select>
                <label class="toggle-comments"><input type="checkbox" id="ignoreCommentsToggle" /> Ignore comments</label>
                <span id="fileTypeBadge" class="file-type-badge" style="display: none;"></span>
            </div>
            <div class="filter-controls" id="filterControls" style="display: none;">
                <div class="filter-section">
                    <label>Filter by Status:</label>
                    <select id="statusFilter">
                        <option value="all">All Status</option>
                        <option value="pass">Pass Only</option>
                        <option value="fail">Fail Only</option>
                        <option value="timeout">Timeout Only</option>
                        <option value="not-evaluated">Not Evaluated</option>
                    </select>
                </div>
                <div class="filter-section">
                    <label>Sort by:</label>
                    <select id="sortBy">
                        <option value="task_id">Task ID</option>
                        <option value="status">Status</option>
                        <option value="bleu_score_asc">BLEU Score (Low to High)</option>
                        <option value="bleu_score_desc">BLEU Score (High to Low)</option>
                        <option value="meteor_score_asc">METEOR Score (Low to High)</option>
                        <option value="meteor_score_desc">METEOR Score (High to Low)</option>
                        <option value="rouge1_fmeasure_asc">ROUGE-1 F-measure (Low to High)</option>
                        <option value="rouge1_fmeasure_desc">ROUGE-1 F-measure (High to Low)</option>
                        <option value="rougeL_fmeasure_asc">ROUGE-L F-measure (Low to High)</option>
                        <option value="rougeL_fmeasure_desc">ROUGE-L F-measure (High to Low)</option>
                        <option value="codebleu_asc">CodeBLEU Score (Low to High)</option>
                        <option value="codebleu_desc">CodeBLEU Score (High to Low)</option>
                        <option value="edit_distance_asc">Edit Distance (Low to High)</option>
                        <option value="edit_distance_desc">Edit Distance (High to Low)</option>
                        <option value="levenshtein_asc">Levenshtein Distance (Low to High)</option>
                        <option value="levenshtein_desc">Levenshtein Distance (High to Low)</option>
                    </select>
                </div>
                <div class="filter-section">
                    <label>Compare:</label>
                    <select id="metricComparison">
                        <option value="llm_vs_canonical">LLM vs Canonical</option>
                        <option value="llm_vs_corrupted">LLM vs Corrupted</option>
                        <option value="corrupted_vs_canonical">Corrupted vs Canonical</option>
                    </select>
                </div>
                <button id="applyFilters" class="apply-filters-btn">Apply Filters</button>
            </div>
            <div class="metrics" id="metrics"></div>
        </div>

        <div id="content" style="display: none;">
            <div class="insights-panel" id="insightsPanel">
                <div class="insights-header">Evaluation Insights</div>
                <div class="insights-grid" id="insightsGrid">
                    <!-- Insights will be populated here -->
                </div>
            </div>
            
            <div class="content">
                <div class="code-panel" id="originalPanel">
                    <div class="code-header">
                        <span>Original Solution</span>
                        <button class="maximize-btn" onclick="toggleMaximize('originalPanel')">Maximize</button>
                    </div>
                    <div class="code-content">
                        <div class="code-block" id="originalCode">No data loaded</div>
                    </div>
                </div>

                <div class="code-panel" id="corruptedPanel">
                    <div class="code-header">
                        <span>Corrupted Solution</span>
                        <button class="maximize-btn" onclick="toggleMaximize('corruptedPanel')">Maximize</button>
                    </div>
                    <div class="code-content">
                        <div class="code-block" id="corruptedCode">No data loaded</div>
                    </div>
                </div>

                <div class="code-panel" id="llmPanel">
                    <div class="code-header">
                        <span>LLM Solution</span>
                        <button class="maximize-btn" onclick="toggleMaximize('llmPanel')">Maximize</button>
                        <span id="statusBadge" class="status-badge"></span>
                    </div>
                    <div class="code-content">
                        <div class="code-block" id="llmCode">No data loaded</div>
                    </div>
                </div>

                <div class="code-panel" id="rawResponsePanel">
                    <div class="code-header">
                        <span>Raw LLM Response</span>
                        <button class="maximize-btn" onclick="toggleMaximize('rawResponsePanel')">Maximize</button>
                    </div>
                    <div class="code-content">
                        <div class="code-block" id="rawResponseCode">No raw data loaded</div>
                    </div>
                </div>

                <div class="code-panel" id="promptPanel">
                    <div class="code-header">
                        <span>Prompt</span>
                        <button class="maximize-btn" onclick="toggleMaximize('promptPanel')">Maximize</button>
                    </div>
                    <div class="code-content">
                        <div class="code-block" id="promptCode">No raw data loaded</div>
                    </div>
                </div>
            </div>

            <div class="reasoning-panel" id="reasoningPanel" style="display: none;">
                <div class="reasoning-header">
                    <span>LLM Reasoning</span>
                    <div>
                        <button class="maximize-btn" onclick="toggleReasoningExpansion()" id="reasoningToggleBtn">Show</button>
                        <button class="maximize-btn" onclick="toggleMaximizeReasoning()" id="reasoningMaxBtn" style="display: none;">Maximize</button>
                    </div>
                </div>
                <div class="reasoning-content" id="reasoningContentContainer" style="display: none;">
                    <div class="code-block" id="reasoningContent">No reasoning available</div>
                </div>
            </div>

            <div class="reasoning-panel" id="errorDetailsPanel" style="display: none;">
                <div class="reasoning-header">
                    Error Details
                </div>
                <div class="reasoning-content">
                    <div class="code-block" id="errorDetailsContent">No error details available</div>
                </div>
            </div>

            <div class="diff-view">
                <div class="diff-header">
                    Code Differences
                </div>
                <div class="diff-content">
                    <div class="diff-selector">
                        <label>Compare:</label>
                        <select id="diffSelector">
                            <option value="corrupted-original">Corrupted vs Original</option>
                            <option value="corrupted-llm">Corrupted vs LLM</option>
                            <option value="original-llm">Original vs LLM</option>
                        </select>
                    </div>
                    <div class="diff-block" id="diffView">Select a task to view differences</div>
                </div>
            </div>

            <div class="metrics-view" id="metricsView" style="display: none;">
                <div class="metrics-header">
                    Similarity Metrics
                </div>
                <div class="metrics-content" id="metricsContent">
                    <!-- Metrics will be populated here -->
                </div>
            </div>
        </div>

        <div id="loading" class="loading">
            Load a JSON evaluation results file or JSONL generated solutions file to get started
        </div>
    </div>

    <script>
        let evaluationData = null;
        let currentTask = null;
        let fileType = null; // 'evaluation' or 'solutions'
        let allTasks = []; // Store all tasks for filtering/sorting
        let filteredTasks = []; // Store filtered tasks
        let maximizedPanel = null;
        let maximizedReasoning = false;
        let reasoningExpanded = false;
        let ignoreCommentsMode = false;

        function toggleReasoningExpansion() {
            const reasoningContentContainer = document.getElementById('reasoningContentContainer');
            const toggleBtn = document.getElementById('reasoningToggleBtn');
            const maxBtn = document.getElementById('reasoningMaxBtn');

            if (reasoningExpanded) {
                // Hide reasoning content
                reasoningContentContainer.style.display = 'none';
                maxBtn.style.display = 'none';
                toggleBtn.textContent = 'Show';
                reasoningExpanded = false;
            } else {
                // Show reasoning content
                reasoningContentContainer.style.display = 'block';
                maxBtn.style.display = 'inline-block';
                toggleBtn.textContent = 'Hide';
                reasoningExpanded = true;
            }
        }

        function toggleMaximizeReasoning() {
            const reasoningContentContainer = document.getElementById('reasoningContentContainer');
            const maxBtn = document.getElementById('reasoningMaxBtn');
            const contentDiv = document.getElementById('content');
            const insightsPanel = document.getElementById('insightsPanel');
            const diffView = document.querySelector('.diff-view');
            const metricsView = document.getElementById('metricsView');
            const errorDetailsPanel = document.getElementById('errorDetailsPanel');

            // Make sure reasoning is expanded first
            if (!reasoningExpanded) {
                toggleReasoningExpansion();
            }

            if (maximizedReasoning) {
                // Minimize - restore normal layout
                if (reasoningContentContainer) reasoningContentContainer.style.maxHeight = '400px';
                if (maxBtn) maxBtn.textContent = 'Maximize';
                
                // Show other panels
                if (contentDiv) contentDiv.style.display = 'block';
                if (insightsPanel) insightsPanel.style.display = 'block';
                if (diffView) diffView.style.display = 'block';
                if (metricsView && metricsView.style.display === 'block') metricsView.style.display = 'block';
                if (errorDetailsPanel && errorDetailsPanel.style.display === 'block') errorDetailsPanel.style.display = 'block';
                
                maximizedReasoning = false;
            } else {
                // If a code panel is maximized, restore it first
                if (maximizedPanel) {
                    toggleMaximize(maximizedPanel);
                }

                // Maximize - hide other panels and expand reasoning
                if (reasoningContentContainer) reasoningContentContainer.style.maxHeight = '80vh';
                if (maxBtn) maxBtn.textContent = 'Minimize';
                
                // Hide other panels
                if (contentDiv) contentDiv.style.display = 'none';
                if (insightsPanel) insightsPanel.style.display = 'none';
                if (diffView) diffView.style.display = 'none';
                if (metricsView) metricsView.style.display = 'none';
                if (errorDetailsPanel) errorDetailsPanel.style.display = 'none';
                
                maximizedReasoning = true;
            }
        }

        function toggleMaximize(panelId) {
            const panel = document.getElementById(panelId);
            const contentDiv = document.querySelector('.content');
            const allPanels = document.querySelectorAll('.code-panel');
            const button = panel.querySelector('.maximize-btn');

            // If reasoning is maximized, restore it first
            if (maximizedReasoning) {
                toggleMaximizeReasoning();
            }

            if (maximizedPanel === panelId) {
                // Minimize - show all panels
                allPanels.forEach(p => p.classList.remove('hidden'));
                contentDiv.classList.remove('maximized');
                button.textContent = 'Maximize';
                maximizedPanel = null;
            } else {
                // Maximize - hide other panels
                allPanels.forEach(p => {
                    if (p.id !== panelId) {
                        p.classList.add('hidden');
                    } else {
                        p.classList.remove('hidden');
                    }
                });
                contentDiv.classList.add('maximized');
                
                // Update all buttons
                allPanels.forEach(p => {
                    const btn = p.querySelector('.maximize-btn');
                    if (p.id === panelId) {
                        btn.textContent = 'Minimize';
                    } else {
                        btn.textContent = 'Maximize';
                    }
                });
                
                maximizedPanel = panelId;
            }
        }

        const fileInput = document.getElementById('fileInput');
        const taskSelector = document.getElementById('taskSelector');
        const diffSelector = document.getElementById('diffSelector');
        const metricsDiv = document.getElementById('metrics');
        const contentDiv = document.getElementById('content');
        const loadingDiv = document.getElementById('loading');
        const fileTypeBadge = document.getElementById('fileTypeBadge');
        const reasoningPanel = document.getElementById('reasoningPanel');
        const filterControls = document.getElementById('filterControls');
        const statusFilter = document.getElementById('statusFilter');
        const sortBy = document.getElementById('sortBy');
        const metricComparison = document.getElementById('metricComparison');
        const applyFilters = document.getElementById('applyFilters');
        const insightsPanel = document.getElementById('insightsPanel');
        const insightsGrid = document.getElementById('insightsGrid');
        const ignoreCommentsToggle = document.getElementById('ignoreCommentsToggle');

        fileInput.addEventListener('change', handleFileLoad);
        taskSelector.addEventListener('change', handleTaskChange);
        diffSelector.addEventListener('change', updateDiff);
        applyFilters.addEventListener('click', applyFiltersAndSort);
        statusFilter.addEventListener('change', applyFiltersAndSort);
        sortBy.addEventListener('change', applyFiltersAndSort);
        metricComparison.addEventListener('change', applyFiltersAndSort);
        ignoreCommentsToggle.addEventListener('change', handleIgnoreCommentsToggle);

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const content = e.target.result;
                    
                    // Detect file format - be more precise about detection
                    if (file.name.endsWith('.jsonl')) {
                        // JSONL format (generated solutions)
                        fileType = 'solutions';
                        evaluationData = parseJSONL(content);
                        fileTypeBadge.textContent = 'Generated Solutions';
                        fileTypeBadge.style.display = 'inline-block';
                        
                        // For small files, parseJSONL returns complete data
                        // For large files, it processes asynchronously and calls loadTasks/showOverallMetrics itself
                        if (content.trim().split('\n').length <= 100) {
                            loadTasks();
                            showOverallMetrics();
                        }
                    } else if (file.name.endsWith('.json')) {
                        // JSON format (evaluation results)
                        fileType = 'evaluation';
                        
                        // Parse JSON in chunks for large files
                        const contentSize = content.length;
                        if (contentSize > 1000000) { // 1MB
                            loadingDiv.textContent = 'Parsing large JSON file...';
                            setTimeout(() => {
                                try {
                                    evaluationData = JSON.parse(content);
                                    fileTypeBadge.textContent = 'Evaluation Results';
                                    fileTypeBadge.style.display = 'inline-block';
                                    loadTasks();
                                    showOverallMetrics();
                                } catch (error) {
                                    showError('Error parsing JSON: ' + error.message);
                                }
                            }, 100);
                        } else {
                            evaluationData = JSON.parse(content);
                            fileTypeBadge.textContent = 'Evaluation Results';
                            fileTypeBadge.style.display = 'inline-block';
                            loadTasks();
                            showOverallMetrics();
                        }
                    } else {
                        // Fallback: try to detect based on content structure
                        try {
                            const parsed = JSON.parse(content);
                            if (parsed.eval && typeof parsed.eval === 'object') {
                                // Has eval object - this is evaluation results
                                fileType = 'evaluation';
                                evaluationData = parsed;
                                fileTypeBadge.textContent = 'Evaluation Results';
                                fileTypeBadge.style.display = 'inline-block';
                                loadTasks();
                                showOverallMetrics();
                            } else {
                                showError('Unrecognized file format. Expected JSON evaluation results or JSONL solutions file.');
                            }
                        } catch (jsonError) {
                            // Try parsing as JSONL
                            fileType = 'solutions';
                            evaluationData = parseJSONL(content);
                            fileTypeBadge.textContent = 'Generated Solutions';
                            fileTypeBadge.style.display = 'inline-block';
                            
                            if (content.trim().split('\n').length <= 100) {
                                loadTasks();
                                showOverallMetrics();
                            }
                        }
                    }
                } catch (error) {
                    showError('Error parsing file: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        function parseJSONL(content) {
            const lines = content.trim().split('\n');
            const data = { eval: {} };
            
            // Process in chunks to prevent blocking on large files
            const MAX_LINES_PER_CHUNK = 100;
            let currentIndex = 0;
            
            function processChunk() {
                const endIndex = Math.min(currentIndex + MAX_LINES_PER_CHUNK, lines.length);
                
                for (let i = currentIndex; i < endIndex; i++) {
                    const line = lines[i];
                    if (line.trim()) {
                        try {
                            const item = JSON.parse(line);
                            data.eval[item.task_id] = {
                                task_id: item.task_id,
                                solution: item.solution,
                                canonical_solution: item.canonical_solution,
                                corrupted_solution: item.corrupted_solution,
                                llm_response: item.llm_response,
                                llm_reasoning: item.llm_reasoning,
                                prompt: item.prompt,
                                test_code: item.test_code,
                                status: 'not-evaluated', // Default status for generated solutions
                                similarity_metrics: item.similarity_metrics || {} // Store new similarity metrics
                            };
                        } catch (e) {
                            console.warn('Error parsing line:', line.substring(0, 100) + '...', e);
                        }
                    }
                }
                
                currentIndex = endIndex;
                
                // If there are more lines, process them in the next frame
                if (currentIndex < lines.length) {
                    // Update loading message
                    loadingDiv.textContent = `Parsing file... ${Math.round(currentIndex / lines.length * 100)}%`;
                    setTimeout(processChunk, 10);
                } else {
                    // Finished parsing
                    loadTasks();
                    showOverallMetrics();
                }
            }
            
            // Start processing
            if (lines.length > MAX_LINES_PER_CHUNK) {
                loadingDiv.textContent = 'Parsing large file...';
                setTimeout(processChunk, 10);
                return data; // Return partial data, will be populated asynchronously
            } else {
                // For small files, process synchronously
                lines.forEach(line => {
                    if (line.trim()) {
                        try {
                            const item = JSON.parse(line);
                            data.eval[item.task_id] = {
                                task_id: item.task_id,
                                solution: item.solution,
                                canonical_solution: item.canonical_solution,
                                corrupted_solution: item.corrupted_solution,
                                llm_response: item.llm_response,
                                llm_reasoning: item.llm_reasoning,
                                prompt: item.prompt,
                                test_code: item.test_code,
                                status: 'not-evaluated',
                                similarity_metrics: item.similarity_metrics || {} // Store new similarity metrics
                            };
                        } catch (e) {
                            console.warn('Error parsing line:', line, e);
                        }
                    }
                });
                return data;
            }
        }

        function loadTasks() {
            const tasks = Object.keys(evaluationData.eval || {});
            
            console.log('Debug: loadTasks called');
            console.log('Debug: evaluationData structure:', evaluationData);
            console.log('Debug: eval keys:', Object.keys(evaluationData.eval || {}));
            console.log('Debug: fileType:', fileType);
            console.log('Debug: total tasks found:', tasks.length);
            
            // Store all tasks data with metadata for filtering/sorting
            allTasks = tasks.map(taskId => {
                const taskData = evaluationData.eval[taskId];
                return {
                    taskId,
                    status: taskData.status || 'not-evaluated',
                    data: taskData
                };
            });
            
            console.log('Debug: allTasks length:', allTasks.length);
            console.log('Debug: sample task data:', allTasks[0]);
            
            // Show filter controls for evaluation results
            if (fileType === 'evaluation') {
                filterControls.style.display = 'flex';
                generateInsights();
            } else {
                filterControls.style.display = 'none';
                insightsPanel.style.display = 'none';
            }
            
            // Apply initial filtering and sorting
            applyFiltersAndSort();

            taskSelector.disabled = false;
        }

        function showOverallMetrics() {
            if (!evaluationData) return;

            const tasks = Object.keys(evaluationData.eval || {});
            let metrics = [
                `<div class="metric">Total Tasks: ${tasks.length}</div>`,
                `<div class="metric">File Type: ${fileType === 'solutions' ? 'Generated Solutions' : 'Evaluation Results'}</div>`
            ];

            if (fileType === 'evaluation') {
                const passed = tasks.filter(taskId => 
                    evaluationData.eval[taskId].status === 'pass'
                ).length;
                
                const passRate = tasks.length > 0 ? (passed / tasks.length * 100).toFixed(1) : 0;
                
                metrics.push(
                    `<div class="metric">Passed: ${passed}</div>`,
                    `<div class="metric">Pass Rate: ${passRate}%</div>`
                );

                // Indicate if similarity data is available
                if (evaluationData.similarity) {
                    metrics.push(`<div class="metric">Similarity Metrics: Available</div>`);
                } else {
                    metrics.push(`<div class="metric">Similarity Metrics: Not Available</div>`);
                }
            }

            if (evaluationData.date) {
                metrics.push(`<div class="metric">Date: ${evaluationData.date}</div>`);
            }

            metricsDiv.innerHTML = metrics.join('');
        }

        function handleTaskChange(event) {
            const taskId = event.target.value;
            if (!taskId || !evaluationData) return;

            currentTask = taskId;
            const taskData = evaluationData.eval[taskId];
            
            displayCode(taskData);
            
            // Compute the default diff (corrupted-original) 
            updateDiff();
            
            contentDiv.style.display = 'block';
            loadingDiv.style.display = 'none';
        }

        function handleIgnoreCommentsToggle() {
            ignoreCommentsMode = ignoreCommentsToggle.checked;
            if (currentTask && evaluationData && evaluationData.eval[currentTask]) {
                displayCode(evaluationData.eval[currentTask]);
                updateDiff();
            }
        }
        
        function applyFiltersAndSort() {
            // Filter tasks
            const statusFilterValue = statusFilter.value;
            filteredTasks = allTasks.filter(task => {
                if (statusFilterValue === 'all') return true;
                return task.status === statusFilterValue;
            });
            
            // Sort tasks
            const sortByValue = sortBy.value;
            const comparisonType = metricComparison.value;
            
            filteredTasks.sort((a, b) => {
                if (sortByValue === 'task_id') {
                    return a.taskId.localeCompare(b.taskId);
                } else if (sortByValue === 'status') {
                    const statusOrder = { 'fail': 0, 'timeout': 1, 'not-evaluated': 2, 'pass': 3 };
                    return statusOrder[a.status] - statusOrder[b.status];
                } else if (sortByValue.includes('bleu_score')) {
                    const aValue = getMetricValue(a, comparisonType, 'bleu_score');
                    const bValue = getMetricValue(b, comparisonType, 'bleu_score');
                    return sortByValue.endsWith('_asc') ? aValue - bValue : bValue - aValue;
                } else if (sortByValue.includes('meteor_score')) {
                    const aValue = getMetricValue(a, comparisonType, 'meteor_score');
                    const bValue = getMetricValue(b, comparisonType, 'meteor_score');
                    return sortByValue.endsWith('_asc') ? aValue - bValue : bValue - aValue;
                } else if (sortByValue.includes('rouge1_fmeasure')) {
                    const aValue = getMetricValue(a, comparisonType, 'rouge1_fmeasure');
                    const bValue = getMetricValue(b, comparisonType, 'rouge1_fmeasure');
                    return sortByValue.endsWith('_asc') ? aValue - bValue : bValue - aValue;
                } else if (sortByValue.includes('rougeL_fmeasure')) {
                    const aValue = getMetricValue(a, comparisonType, 'rougeL_fmeasure');
                    const bValue = getMetricValue(b, comparisonType, 'rougeL_fmeasure');
                    return sortByValue.endsWith('_asc') ? aValue - bValue : bValue - aValue;
                } else if (sortByValue.includes('codebleu')) {
                    const aValue = getMetricValue(a, comparisonType, 'codebleu');
                    const bValue = getMetricValue(b, comparisonType, 'codebleu');
                    return sortByValue.endsWith('_asc') ? aValue - bValue : bValue - aValue;
                } else if (sortByValue.includes('edit_distance')) {
                    const aValue = getMetricValue(a, comparisonType, 'edit_distance');
                    const bValue = getMetricValue(b, comparisonType, 'edit_distance');
                    return sortByValue.endsWith('_asc') ? aValue - bValue : bValue - aValue;
                } else if (sortByValue.includes('levenshtein')) {
                    const aValue = getMetricValue(a, comparisonType, 'levenshtein_distance');
                    const bValue = getMetricValue(b, comparisonType, 'levenshtein_distance');
                    return sortByValue.endsWith('_asc') ? aValue - bValue : bValue - aValue;
                } else {
                    // Fallback to task_id sorting if similarity data not available
                    return a.taskId.localeCompare(b.taskId);
                }
            });
            
            updateTaskSelector();
            updateSortOptions();
        }

        function updateSortOptions() {
            // Enable/disable metric-based sorting options based on similarity data availability
            const metricOptions = sortBy.querySelectorAll('option[value*="bleu_score"], option[value*="meteor_score"], option[value*="rouge"], option[value*="codebleu"], option[value*="edit_distance"], option[value*="levenshtein"]');
            
            // Check if any task has similarity metrics (new structure or old structure)
            const hasSimilarity = allTasks.some(task => 
                (task.data.similarity_metrics && Object.keys(task.data.similarity_metrics).length > 0) ||
                (evaluationData.similarity && evaluationData.similarity[task.taskId])
            );
            
            metricOptions.forEach(option => {
                option.disabled = !hasSimilarity;
                if (!hasSimilarity && option.selected) {
                    // Reset to task_id if currently selected metric option is disabled
                    sortBy.value = 'task_id';
                }
            });

            // Also disable metric comparison if no similarity data
            metricComparison.disabled = !hasSimilarity;
        }
        
        function getMetricValue(task, comparisonType, metricName) {
            // Check new structure first (individual sample metrics)
            if (task.data.similarity_metrics && task.data.similarity_metrics[comparisonType]) {
                return task.data.similarity_metrics[comparisonType][metricName] || 0;
            }
            
            // Fallback to old structure for backward compatibility
            if (!evaluationData.similarity || !evaluationData.similarity[task.taskId]) {
                return 0;
            }
            
            const similarities = evaluationData.similarity[task.taskId];
            const comparison = similarities[comparisonType];
            
            if (!comparison) return 0;
            
            return comparison[metricName] || 0;
        }
        
        function updateTaskSelector() {
            taskSelector.innerHTML = '<option value="">Select a task...</option>';
            
            filteredTasks.forEach(task => {
                const option = document.createElement('option');
                option.value = task.taskId;
                
                // Create status indicator
                const statusIndicator = getStatusIndicator(task.status);
                option.textContent = `${statusIndicator} ${task.taskId}`;
                
                taskSelector.appendChild(option);
            });
            
            loadingDiv.textContent = `Showing ${filteredTasks.length}/${allTasks.length} tasks. Select a task to view code.`;
        }
        
        function getStatusIndicator(status) {
            const indicators = {
                'pass': '✅',
                'fail': '❌',
                'timeout': '⏱️',
                'not-evaluated': '⚪'
            };
            return indicators[status] || '❓';
        }
        
        function generateInsights() {
            if (!allTasks.length) return;
            
            // Calculate basic statistics
            const totalTasks = allTasks.length;
            const failedTasks = allTasks.filter(task => task.status === 'fail').length;
            const passedTasks = allTasks.filter(task => task.status === 'pass').length;
            const timeoutTasks = allTasks.filter(task => task.status === 'timeout').length;
            const notEvaluatedTasks = allTasks.filter(task => task.status === 'not-evaluated').length;
            
            let insights = [
                {
                    title: 'Failed Tests',
                    value: failedTasks,
                    description: `${failedTasks} out of ${totalTasks} tasks failed (${((failedTasks/totalTasks)*100).toFixed(1)}%)`,
                    type: 'fail'
                },
                {
                    title: 'Passed Tests',
                    value: passedTasks,
                    description: `${passedTasks} out of ${totalTasks} tasks passed (${((passedTasks/totalTasks)*100).toFixed(1)}%)`,
                    type: 'pass'
                }
            ];

            if (timeoutTasks > 0) {
                insights.push({
                    title: 'Timeout Tests',
                    value: timeoutTasks,
                    description: `${timeoutTasks} out of ${totalTasks} tasks timed out (${((timeoutTasks/totalTasks)*100).toFixed(1)}%)`,
                    type: 'timeout'
                });
            }

            if (notEvaluatedTasks > 0) {
                insights.push({
                    title: 'Not Evaluated',
                    value: notEvaluatedTasks,
                    description: `${notEvaluatedTasks} out of ${totalTasks} tasks not evaluated`,
                    type: 'not-evaluated'
                });
            }
            
            // Add similarity insights if available (check new structure first)
            const tasksWithSimilarity = allTasks.filter(task => 
                (task.data.similarity_metrics && 
                 task.data.similarity_metrics.llm_vs_canonical &&
                 Object.keys(task.data.similarity_metrics).length > 0) ||
                (evaluationData.similarity && 
                 evaluationData.similarity[task.taskId] && 
                 evaluationData.similarity[task.taskId].llm_vs_canonical)
            );
            
            if (tasksWithSimilarity.length > 0) {
                // Calculate average BLEU score (with comments)
                const bleuScores = tasksWithSimilarity.map(task => {
                    // Try new structure first
                    if (task.data.similarity_metrics && task.data.similarity_metrics.llm_vs_canonical) {
                        return task.data.similarity_metrics.llm_vs_canonical.bleu_score || 0;
                    }
                    // Fallback to old structure
                    const similarity = evaluationData.similarity[task.taskId].llm_vs_canonical;
                    return similarity.bleu_score || 0;
                });
                
                const avgBleuScore = bleuScores.reduce((sum, score) => sum + score, 0) / bleuScores.length;
                
                insights.push({
                    title: 'Average BLEU Score',
                    value: avgBleuScore.toFixed(3),
                    description: `Average similarity between LLM and canonical solutions (with comments)`,
                    type: 'metric'
                });
                
                // Calculate average METEOR score
                const meteorScores = tasksWithSimilarity.map(task => {
                    // Try new structure first
                    if (task.data.similarity_metrics && task.data.similarity_metrics.llm_vs_canonical) {
                        return task.data.similarity_metrics.llm_vs_canonical.meteor_score || 0;
                    }
                    return 0;
                }).filter(score => score > 0);
                
                if (meteorScores.length > 0) {
                    const avgMeteorScore = meteorScores.reduce((sum, score) => sum + score, 0) / meteorScores.length;
                    insights.push({
                        title: 'Average METEOR Score',
                        value: avgMeteorScore.toFixed(3),
                        description: `Average METEOR similarity between LLM and canonical solutions`,
                        type: 'metric'
                    });
                }
                
                // Calculate average CodeBLEU score
                const codebleuScores = tasksWithSimilarity.map(task => {
                    // Try new structure first
                    if (task.data.similarity_metrics && task.data.similarity_metrics.llm_vs_canonical) {
                        return task.data.similarity_metrics.llm_vs_canonical.codebleu || 0;
                    }
                    return 0;
                }).filter(score => score > 0);
                
                if (codebleuScores.length > 0) {
                    const avgCodebleuScore = codebleuScores.reduce((sum, score) => sum + score, 0) / codebleuScores.length;
                    insights.push({
                        title: 'Average CodeBLEU Score',
                        value: avgCodebleuScore.toFixed(3),
                        description: `Average CodeBLEU similarity between LLM and canonical solutions`,
                        type: 'metric'
                    });
                }
                
                // Calculate average BLEU score without comments if available
                const bleuScoresNoComments = tasksWithSimilarity.map(task => {
                    // Try new structure first
                    if (task.data.similarity_metrics && task.data.similarity_metrics.llm_vs_canonical) {
                        return task.data.similarity_metrics.llm_vs_canonical.no_comments_bleu_score || 0;
                    }
                    // For old structure, no-comment metrics might not be available
                    return 0;
                }).filter(score => score > 0); // Only include tasks that have no-comment metrics
                
                if (bleuScoresNoComments.length > 0) {
                    const avgBleuScoreNoComments = bleuScoresNoComments.reduce((sum, score) => sum + score, 0) / bleuScoresNoComments.length;
                    
                    insights.push({
                        title: 'Average BLEU Score (No Comments)',
                        value: avgBleuScoreNoComments.toFixed(3),
                        description: `Average similarity between LLM and canonical solutions (without comments)`,
                        type: 'metric'
                    });
                }
            } else {
                // Add note about missing similarity data
                insights.push({
                    title: 'Similarity Metrics',
                    value: 'N/A',
                    description: 'Similarity metrics not available - file was generated without --eval_similarity flag',
                    type: 'metric'
                });
            }
            
            // Render insights
            insightsGrid.innerHTML = insights.map(insight => `
                <div class="insight-item ${insight.type}">
                    <div class="insight-title">${insight.title}</div>
                    <div class="insight-value">${insight.value}</div>
                    <div class="insight-description">${insight.description}</div>
                </div>
            `).join('');
        }

        function displayCode(taskData) {
            // Display content with truncation for performance
            const corruptedShown = ignoreCommentsMode ? stripComments(taskData.corrupted_solution || '') : (taskData.corrupted_solution || '');
            const originalShown = ignoreCommentsMode ? stripComments(taskData.canonical_solution || '') : (taskData.canonical_solution || '');
            const llmShown = ignoreCommentsMode ? stripComments(taskData.solution || '') : (taskData.solution || '');

            displayCodePanel('corruptedCode', corruptedShown || 'No corrupted solution available');
            displayCodePanel('originalCode', originalShown || 'No original solution available');
            displayCodePanel('llmCode', llmShown || 'No LLM solution available');

            // Display raw LLM response and prompt if available
            if (taskData.llm_response && taskData.prompt) {
                displayCodePanel('rawResponseCode', taskData.llm_response);
                displayCodePanel('promptCode', taskData.prompt);
            } else if (taskData.llm_response) {
                displayCodePanel('rawResponseCode', taskData.llm_response);
                displayCodePanel('promptCode', 'No prompt available in this evaluation file');
            } else if (taskData.prompt) {
                displayCodePanel('rawResponseCode', 'No raw LLM response available in this evaluation file');
                displayCodePanel('promptCode', taskData.prompt);
            } else {
                displayCodePanel('rawResponseCode', 'No raw LLM response available - evaluation file may be from older version');
                displayCodePanel('promptCode', 'No prompt available - evaluation file may be from older version');
            }

            // Update status badge
            const statusBadge = document.getElementById('statusBadge');
            const status = taskData.status || 'unknown';
            statusBadge.textContent = status;
            statusBadge.className = `status-badge status-${status}`;

            // Always show reasoning panel with appropriate message
            if (taskData.llm_reasoning && taskData.llm_reasoning.trim()) {
                displayCodePanel('reasoningContent', taskData.llm_reasoning);
            } else {
                displayCodePanel('reasoningContent', 'No reasoning available for this task');
            }
            reasoningPanel.style.display = 'block';

            // Show error details panel if available
            displayErrorDetails(taskData);

            // Display metrics if available
            displayMetrics(taskData);
        }

        function displayCodePanel(elementId, content) {
            const element = document.getElementById(elementId);
            const container = element.parentElement;
            
            // Remove any existing show more button
            const existingBtn = container.querySelector('.show-more-btn');
            if (existingBtn) {
                existingBtn.remove();
            }
            
            // Show all content without truncation
            element.textContent = content;
            element.className = 'code-block';
        }
        


        function displayErrorDetails(taskData) {
            const errorDetailsPanel = document.getElementById('errorDetailsPanel');
            const errorDetailsContent = document.getElementById('errorDetailsContent');
            
            // Check if we have error details
            if (taskData.details && typeof taskData.details === 'object' && Object.keys(taskData.details).length > 0) {
                let errorHtml = '';
                let hasActualErrors = false;
                
                for (const [key, value] of Object.entries(taskData.details)) {
                    // Skip TEST_STATS as it's just informational
                    if (key === 'TEST_STATS') {
                        continue;
                    }
                    
                    hasActualErrors = true;
                    
                    if (key === 'ALL') {
                        errorHtml += `<div style="margin-bottom: 20px;">
                            <div style="color: #e74c3c; font-weight: bold; margin-bottom: 10px;">General Error:</div>
                            <div style="background: #2c1810; padding: 10px; border-left: 3px solid #e74c3c; white-space: pre-wrap;">${escapeHtml(value)}</div>
                        </div>`;
                    } else if (key === 'ERROR_OUTPUT') {
                        errorHtml += `<div style="margin-bottom: 20px;">
                            <div style="color: #e74c3c; font-weight: bold; margin-bottom: 10px;">Error Output:</div>
                            <div style="background: #2c1810; padding: 10px; border-left: 3px solid #e74c3c; white-space: pre-wrap;">${escapeHtml(value)}</div>
                        </div>`;
                    } else {
                        // Individual test failure
                        errorHtml += `<div style="margin-bottom: 20px;">
                            <div style="color: #e74c3c; font-weight: bold; margin-bottom: 10px;">Test Failure: ${escapeHtml(key)}</div>
                            <div style="background: #2c1810; padding: 10px; border-left: 3px solid #e74c3c; white-space: pre-wrap;">${escapeHtml(value)}</div>
                        </div>`;
                    }
                }
                
                // Add TEST_STATS at the end if available
                if (taskData.details.TEST_STATS) {
                    const stats = taskData.details.TEST_STATS;
                    errorHtml += `<div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #404040;">
                        <div style="color: #3498db; font-weight: bold; margin-bottom: 10px;">Test Statistics:</div>
                        <div style="background: #1a2332; padding: 10px; border-left: 3px solid #3498db;">
                            Tests Run: ${stats.tests_run || 0}<br>
                            Failures: ${stats.failures || 0}<br>
                            Errors: ${stats.errors || 0}<br>
                            Skipped: ${stats.skipped || 0}<br>
                            Was Successful: ${stats.was_successful || false}
                        </div>
                    </div>`;
                }
                
                if (hasActualErrors) {
                    errorDetailsContent.innerHTML = errorHtml;
                    errorDetailsPanel.style.display = 'block';
                } else {
                    // Only TEST_STATS available, still show it but with different styling
                    errorDetailsContent.innerHTML = errorHtml;
                    errorDetailsPanel.style.display = 'block';
                }
            } else {
                errorDetailsPanel.style.display = 'none';
            }
        }

        function displayMetrics(taskData) {
            const metricsView = document.getElementById('metricsView');
            const metricsContent = document.getElementById('metricsContent');

            // Check for similarity metrics in the new structure first
            let similarities = null;
            if (taskData.similarity_metrics && Object.keys(taskData.similarity_metrics).length > 0) {
                similarities = taskData.similarity_metrics;
            } else if (evaluationData && evaluationData.similarity && evaluationData.similarity[currentTask]) {
                // Fallback to old structure
                similarities = evaluationData.similarity[currentTask];
            }

            if (similarities) {
                const metricsHtml = generateMetricsHtml(similarities);
                metricsContent.innerHTML = metricsHtml;
                metricsView.style.display = 'block';
            } else {
                metricsView.style.display = 'none';
            }
        }

        function generateMetricsHtml(similarities) {
            let html = '';
            
            for (const [comparisonType, metrics] of Object.entries(similarities)) {
                const displayName = comparisonType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                html += `<div class="comparison-title">${displayName}</div>`;
                
                // Separate metrics by type
                const regularMetrics = {};
                const noCommentMetrics = {};
                const bodyMetrics = {};
                const bodyNoCommentMetrics = {};
                
                for (const [metricName, value] of Object.entries(metrics)) {
                    if (metricName.startsWith('body_no_comments_')) {
                        const cleanName = metricName.replace('body_no_comments_', '');
                        bodyNoCommentMetrics[cleanName] = value;
                    } else if (metricName.startsWith('body_')) {
                        const cleanName = metricName.replace('body_', '');
                        bodyMetrics[cleanName] = value;
                    } else if (metricName.startsWith('no_comments_')) {
                        const cleanName = metricName.replace('no_comments_', '');
                        noCommentMetrics[cleanName] = value;
                    } else {
                        regularMetrics[metricName] = value;
                    }
                }
                
                // Create table
                html += `<table class="metrics-table">`;
                html += `<tr><th>Metric</th><th>With Comments</th><th>Without Comments</th><th>Body Only (With Comments)</th><th>Body Only (Without Comments)</th></tr>`;
                
                // Get all unique metric names
                const allMetricNames = new Set([
                    ...Object.keys(regularMetrics),
                    ...Object.keys(noCommentMetrics),
                    ...Object.keys(bodyMetrics),
                    ...Object.keys(bodyNoCommentMetrics)
                ]);
                
                for (const metricName of allMetricNames) {
                    const displayMetric = formatMetricName(metricName);
                    const regularValue = regularMetrics[metricName] !== undefined ? 
                        (typeof regularMetrics[metricName] === 'number' ? regularMetrics[metricName].toFixed(4) : regularMetrics[metricName]) : '-';
                    const noCommentValue = noCommentMetrics[metricName] !== undefined ? 
                        (typeof noCommentMetrics[metricName] === 'number' ? noCommentMetrics[metricName].toFixed(4) : noCommentMetrics[metricName]) : '-';
                    const bodyValue = bodyMetrics[metricName] !== undefined ? 
                        (typeof bodyMetrics[metricName] === 'number' ? bodyMetrics[metricName].toFixed(4) : bodyMetrics[metricName]) : '-';
                    const bodyNoCommentValue = bodyNoCommentMetrics[metricName] !== undefined ? 
                        (typeof bodyNoCommentMetrics[metricName] === 'number' ? bodyNoCommentMetrics[metricName].toFixed(4) : bodyNoCommentMetrics[metricName]) : '-';
                    
                    html += `<tr>`;
                    html += `<td class="metric-name">${displayMetric}</td>`;
                    html += `<td>${regularValue}</td>`;
                    html += `<td>${noCommentValue}</td>`;
                    html += `<td>${bodyValue}</td>`;
                    html += `<td>${bodyNoCommentValue}</td>`;
                    html += `</tr>`;
                }
                
                html += `</table>`;
            }
            
            return html;
        }

        function formatMetricName(metricName) {
            // Special formatting for common metrics
            const specialNames = {
                'bleu_score': 'BLEU',
                'meteor_score': 'METEOR',
                'codebleu': 'CodeBLEU',
                'rouge1_fmeasure': 'ROUGE-1',
                'rouge2_fmeasure': 'ROUGE-2',
                'rougeL_fmeasure': 'ROUGE-L',
                'levenshtein_distance': 'Levenshtein',
                'edit_distance': 'Edit Dist',
                'normalized_levenshtein': 'Norm Lev',
                'normalized_edit_distance': 'Norm Edit'
            };
            
            if (specialNames[metricName]) {
                return specialNames[metricName];
            }
            
            // Default formatting
            return metricName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        function updateDiff() {
            if (!currentTask || !evaluationData) return;

            const taskData = evaluationData.eval[currentTask];
            
            // Display metrics for the current task
            displayMetrics(taskData);
            
            const diffType = diffSelector.value;
            const diffView = document.getElementById('diffView');

            // If ignoring comments, compute client-side diffs on sanitized code
            if (ignoreCommentsMode) {
                let leftText = '', rightText = '', label1 = '', label2 = '';
                switch (diffType) {
                    case 'corrupted-original':
                        leftText = taskData.corrupted_solution || '';
                        rightText = taskData.canonical_solution || '';
                        label1 = 'Corrupted';
                        label2 = 'Original';
                        break;
                    case 'corrupted-llm':
                        leftText = taskData.corrupted_solution || '';
                        rightText = taskData.solution || '';
                        label1 = 'Corrupted';
                        label2 = 'LLM';
                        break;
                    case 'original-llm':
                        leftText = taskData.canonical_solution || '';
                        rightText = taskData.solution || '';
                        label1 = 'Original';
                        label2 = 'LLM';
                        break;
                }

                const sanitizedLeft = stripComments(leftText);
                const sanitizedRight = stripComments(rightText);
                displayComputedDiff(label1, label2, sanitizedLeft, sanitizedRight, diffView);
                return;
            }

            // Otherwise, prefer pre-calculated diffs when available
            if (taskData.diffs && fileType === 'evaluation') {
                displayPreCalculatedDiff(taskData.diffs, diffType, diffView);
            } else {
                // Fallback to old diff calculation if no pre-calculated diffs
                calculateDiffFallback(taskData, diffType, diffView);
            }
        }

        function displayPreCalculatedDiff(diffs, diffType, diffView) {
            let diffKey;
            let label1, label2;
            
            switch(diffType) {
                case 'corrupted-original':
                    diffKey = 'corrupted_vs_canonical';
                    label1 = 'Corrupted';
                    label2 = 'Original';
                    break;
                case 'corrupted-llm':
                    diffKey = 'corrupted_vs_llm';
                    label1 = 'Corrupted';
                    label2 = 'LLM';
                    break;
                case 'original-llm':
                    diffKey = 'canonical_vs_llm';
                    label1 = 'Original';
                    label2 = 'LLM';
                    break;
            }

            const diffData = diffs[diffKey];
            if (!diffData) {
                diffView.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #888;">
                        <h3>Diff not available</h3>
                        <p>No diff data found for ${label1} vs ${label2}</p>
                    </div>
                `;
                return;
            }

            // Handle summary type (for large files)
            if (diffData.length === 1 && diffData[0].type === 'summary') {
                        diffView.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #888;">
                        <h3>Files too large for diff</h3>
                        <p>${diffData[0].content}</p>
                            </div>
                        `;
                        return;
                    }
                    
            // Handle identical files
            if (diffData.length === 1 && diffData[0].type === 'context') {
                        diffView.innerHTML = `
                            <div style="padding: 20px; text-align: center; color: #2ecc71;">
                                <h3>Files are identical</h3>
                                <p>No differences found between ${label1} and ${label2}</p>
                            </div>
                        `;
                        return;
                    }
                    
            // Render the diff
            let html = `<div style="margin-bottom: 10px; font-weight: bold;">${label1} → ${label2}</div>`;
            
            for (const item of diffData) {
                const lineClass = item.type === 'added' ? 'line-added' : 
                                item.type === 'removed' ? 'line-removed' : 'line-context';
                const prefix = item.type === 'added' ? '+ ' : 
                             item.type === 'removed' ? '- ' : '  ';
                html += `<span class="line ${lineClass}">${escapeHtml(prefix + item.content)}</span>`;
            }
            
            diffView.innerHTML = html;
        }

        function calculateDiffFallback(taskData, diffType, diffView) {
            // Fallback to old calculation method if no pre-calculated diffs available
            diffView.innerHTML = `
                <div style="padding: 20px; text-align: center; color: #888;">
                    <h3>Diff calculation not available</h3>
                    <p>Pre-calculated diffs not found in this file.</p>
                    <p>Use the individual code panels above to compare manually.</p>
                </div>
            `;
        }

        function stripComments(code) {
            // Python-only comment/docstring stripping
            // - Remove triple-quoted docstrings ("""...""" or '''...''') even if multi-line
            // - Remove full-line comments starting with #
            // - Remove inline # comments outside of strings
            if (!code) return code;
            let text = code;
            try { text = text.replace(/(^|[^\\])("""|''')[\s\S]*?\2/gm, (m, p1) => p1 || ''); } catch (e) {}

            function stripInlineHash(line) {
                let inSingle = false, inDouble = false, escaped = false;
                for (let i = 0; i < line.length; i++) {
                    const ch = line[i];
                    if (escaped) { escaped = false; continue; }
                    if (ch === '\\') { escaped = true; continue; }
                    if (!inDouble && ch === '\'') { inSingle = !inSingle; continue; }
                    if (!inSingle && ch === '"') { inDouble = !inDouble; continue; }
                    if (!inSingle && !inDouble && ch === '#') {
                        return line.slice(0, i).trimEnd();
                    }
                }
                return line;
            }

            const lines = text.split('\n');
            const filtered = [];
            for (let line of lines) {
                if (/^\s*#/.test(line)) continue; // full-line comment
                line = stripInlineHash(line);
                filtered.push(line);
            }
            return filtered.join('\n');
        }

        function computeStructuredDiff(leftText, rightText) {
            const a = (leftText || '').split('\n');
            const b = (rightText || '').split('\n');
            const N = a.length, M = b.length;
            const MAX_LINES = 8000; // guard for very large files
            if (N + M > MAX_LINES) {
                return [{ type: 'summary', content: 'Files too large for client-side diff. Please narrow your selection or disable "Ignore comments".' }];
            }

            const trace = [];
            const v = new Map();
            v.set(1, 0);
            let dFound = 0;

            outer: for (let d = 0; d <= N + M; d++) {
                const vd = new Map(v); // snapshot for backtracking
                trace.push(vd);
                for (let k = -d; k <= d; k += 2) {
                    let x;
                    const vkm1 = v.has(k - 1) ? v.get(k - 1) : -Infinity;
                    const vkp1 = v.has(k + 1) ? v.get(k + 1) : -Infinity;
                    if (k === -d || (k !== d && vkm1 < vkp1)) {
                        x = vkp1; // down (insert in b)
                    } else {
                        x = vkm1 + 1; // right (delete from a)
                    }
                    let y = x - k;
                    while (x < N && y < M && a[x] === b[y]) { x++; y++; }
                    v.set(k, x);
                    if (x >= N && y >= M) { dFound = d; break outer; }
                }
            }

            const result = [];
            let x = N, y = M;
            for (let d = dFound; d >= 0; d--) {
                const vd = trace[d];
                const k = x - y;
                let prevK;
                const vkm1 = vd.has(k - 1) ? vd.get(k - 1) : -Infinity;
                const vkp1 = vd.has(k + 1) ? vd.get(k + 1) : -Infinity;
                if (k === -d || (k !== d && vkm1 < vkp1)) {
                    prevK = k + 1; // came from down (insertion)
                } else {
                    prevK = k - 1; // came from right (deletion)
                }
                const xStart = vd.has(prevK) ? vd.get(prevK) : 0;
                const yStart = xStart - prevK;

                // matched (snake)
                while (x > xStart && y > yStart) {
                    result.push({ type: 'context', content: a[x - 1] });
                    x--; y--;
                }
                if (d === 0) break;
                // single edit
                if (prevK === k + 1) {
                    // insertion from b
                    result.push({ type: 'added', content: b[yStart] });
                } else {
                    // deletion from a
                    result.push({ type: 'removed', content: a[xStart] });
                }
                x = xStart; y = yStart;
            }
            return result.reverse();
        }

        function displayComputedDiff(label1, label2, leftText, rightText, diffView) {
            const diffData = computeStructuredDiff(leftText, rightText);
            if (diffData.length === 1 && diffData[0].type === 'summary') {
                diffView.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #888;">
                        <h3>Files too large for diff</h3>
                        <p>${escapeHtml(diffData[0].content)}</p>
                    </div>
                `;
                return;
            }
            let html = `<div style="margin-bottom: 10px; font-weight: bold;">${label1} → ${label2} (comments ignored)</div>`;
            for (const item of diffData) {
                const lineClass = item.type === 'added' ? 'line-added' : 
                                item.type === 'removed' ? 'line-removed' : 'line-context';
                const prefix = item.type === 'added' ? '+ ' : 
                             item.type === 'removed' ? '- ' : '  ';
                html += `<span class="line ${lineClass}">${escapeHtml(prefix + item.content)}</span>`;
            }
            diffView.innerHTML = html;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showError(message) {
            loadingDiv.innerHTML = `<div class="error">${message}</div>`;
        }
    </script>
</body>
</html> 